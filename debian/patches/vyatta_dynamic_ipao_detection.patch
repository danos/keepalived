Add dynamic IP address owner mode detection

By the VRRP RFC any VRRP group that uses an IP address that is present on the
router should be placed into a special mode called IP address owner mode. This
mode changes the priority of the group to 255, ignoring the configured priority.
Currently Keepalived only uses this mode if it is explicitly configured in the
keepalived.conf file and the VIPs must be manually checked to be an address
owner.

For vyatta the keepalived.conf file is generated by python code and in the CLI
it is not possible to set the priority to 255, because of this we need to add
code that will dynamically check for IPAO mode.

Checking for IPAO mode should be done at initial configure and when new IP
addresses are added because of this.

To accomplish this I've added two new variables to the VRRP structure:
 * addr_owner - boolean for if the group is in IPAO mode
 * configured_priority - backup of configured priority, to be reinserted
 	if the group falls out of address owner mode
On initial configuration and when any IP address is added we check each VIP in
the VRRP group against the source address for the interface, if any of them
match then we set the priority to 255, backup the configured priority, and set
the address owner boolean to true.

There's an additional modification for IPv6. As well as checking the IPv6
Link Local source address we also check the IPv6 Global Addresses on the
interface for matching addresses.

---
 keepalived/core/keepalived_netlink.c |   26 ++++++++++-
 keepalived/include/vrrp.h            |    7 +++
 keepalived/include/vrrp_track.h      |    1 
 keepalived/vrrp/vrrp.c               |   80 +++++++++++++++++++++++++++++++++--
 keepalived/vrrp/vrrp_data.c          |    2 
 keepalived/vrrp/vrrp_dbus.c          |    2 
 keepalived/vrrp/vrrp_parser.c        |    2 
 keepalived/vrrp/vrrp_track.c         |    2 
 8 files changed, 115 insertions(+), 7 deletions(-)

--- a/keepalived/include/vrrp.h
+++ b/keepalived/include/vrrp.h
@@ -285,9 +285,15 @@ typedef struct _vrrp_t {
 	uint8_t			effective_priority;	/* effective priority value */
 	int			total_priority;		/* base_priority +/- track_script, track_interface and track_file weights.
 							   effective_priority is this within the range [1,254]. */
+	uint8_t 		configured_priority;/* Priority value group is configured with,
+										 * used for dynamic IPAO detection.
+										 */
 	bool			vipset;			/* All the vips are set ? */
 	list_head_t		vip;			/* ip_address_t - list of virtual ip addresses */
 	unsigned		vip_cnt;		/* size of vip list */
+	bool			addr_owner; 	/* Do any of our vips match the primary IP address
+									 * on the real interface?
+									 */
 	list_head_t		evip;			/* ip_address_t - list of protocol excluded VIPs.
 							 * Those VIPs will not be presents into the
 							 * VRRP adverts
@@ -466,5 +472,6 @@ extern void vrrp_restore_interface(vrrp_
 #ifdef THREAD_DUMP
 extern void register_vrrp_fifo_addresses(void);
 #endif
+extern void vrrp_check_for_owner_mode(vrrp_t *);
 
 #endif
--- a/keepalived/core/keepalived_netlink.c
+++ b/keepalived/core/keepalived_netlink.c
@@ -160,10 +160,32 @@ addr_is_equal2(struct ifaddrmsg* ifa, vo
 		return false;
 	if (vip_addr->ifa.ifa_family == AF_INET) {
 		sin_addr = PTR_CAST(struct in_addr, addr);
+		struct sockaddr_in zero_addr;
+		zero_addr.sin_family = AF_INET;
+		zero_addr.sin_addr.s_addr = 0;
+		struct sockaddr_storage saddr;
+		memset((void *)&saddr, 0, sizeof(struct sockaddr_storage));
+		inet_ip4tosockaddr(&ifp->sin_addr, &saddr);
+		if (inet_sockaddrcmp(&saddr, &zero_addr) == 0)
+			return vip_addr->u.sin.sin_addr.s_addr != sin_addr->s_addr;
 		return vip_addr->u.sin.sin_addr.s_addr == sin_addr->s_addr;
 	}
 
+	struct sockaddr_in6 zero_addr6;
+	zero_addr6.sin6_family = AF_INET6;
+	zero_addr6.sin6_addr.s6_addr32[0] = 0;
+	zero_addr6.sin6_addr.s6_addr32[1] = 0;
+	zero_addr6.sin6_addr.s6_addr32[2] = 0;
+	zero_addr6.sin6_addr.s6_addr32[3] = 0;
+	struct sockaddr_storage saddr;
+	memset((void *)&saddr, 0, sizeof(struct sockaddr_storage));
+	inet_ip6tosockaddr(&ifp->sin6_addr, &saddr);
 	sin6_addr = PTR_CAST(struct in6_addr, addr);
+	if (inet_sockaddrcmp(&saddr, &zero_addr6) == 0)
+		return vip_addr->u.sin6_addr.s6_addr32[0] != sin6_addr->s6_addr32[0] &&
+		       vip_addr->u.sin6_addr.s6_addr32[1] != sin6_addr->s6_addr32[1] &&
+		       vip_addr->u.sin6_addr.s6_addr32[2] != sin6_addr->s6_addr32[2] &&
+		       vip_addr->u.sin6_addr.s6_addr32[3] != sin6_addr->s6_addr32[3];
 	return vip_addr->u.sin6_addr.s6_addr32[0] == sin6_addr->s6_addr32[0] &&
 	       vip_addr->u.sin6_addr.s6_addr32[1] == sin6_addr->s6_addr32[1] &&
 	       vip_addr->u.sin6_addr.s6_addr32[2] == sin6_addr->s6_addr32[2] &&
@@ -986,6 +1008,7 @@ netlink_if_address_filter(__attribute__(
 					 * and see if they can be brought up */
 					list_for_each_entry(top, &ifp->tracking_vrrp, e_list) {
 						vrrp = top->obj.vrrp;
+						vrrp_check_for_owner_mode(vrrp);
 
 						if (vrrp->track_saddr && vrrp->family == ifa->ifa_family)
 							is_tracking_saddr = inaddr_equal(ifa->ifa_family, &vrrp->saddr, addr.addr);
@@ -1112,6 +1135,7 @@ netlink_if_address_filter(__attribute__(
 						continue;
 					if (vrrp->family != ifa->ifa_family)
 						continue;
+					vrrp_check_for_owner_mode(vrrp);
 					if (!inaddr_equal(ifa->ifa_family, vrrp->family == AF_INET ? &(PTR_CAST(struct sockaddr_in, &vrrp->saddr))->sin_addr : (void *)&(PTR_CAST(struct sockaddr_in6, &vrrp->saddr))->sin6_addr, addr.addr))
 						continue;
 
@@ -1144,7 +1168,7 @@ netlink_if_address_filter(__attribute__(
 #ifdef _HAVE_VRRP_VMAC_
 							 vrrp->family == AF_INET ? VRRP_CONFIGURED_IFP(vrrp) :
 #endif
-							 vrrp->ifp) &&
+							 IF_BASE_IFP(vrrp->ifp)) &&
 						 vrrp->family == ifa->ifa_family &&
 						 vrrp->saddr.ss_family != AF_UNSPEC &&
 						 (!vrrp->saddr_from_config || is_tracking_saddr)) {
--- a/keepalived/include/vrrp_track.h
+++ b/keepalived/include/vrrp_track.h
@@ -210,5 +210,6 @@ extern void initialise_tracking_prioriti
 #ifdef _WITH_CN_PROC_
 extern void process_update_track_process_status(vrrp_tracked_process_t *, bool);
 #endif
+extern void initialise_vrrp_tracking_priorities(struct _vrrp_t *);
 
 #endif
--- a/keepalived/vrrp/vrrp.c
+++ b/keepalived/vrrp/vrrp.c
@@ -2528,8 +2528,6 @@ open_vrrp_read_socket(sa_family_t family
 		close(fd);
 		return -1;
 	}
-
-
 	/*
 	 * Bind to device - have to use bind() here as we're using a
 	 * packet socket, see packet(7)
@@ -3176,6 +3174,8 @@ vrrp_complete_instance(vrrp_t * vrrp)
 		vrrp->nopreempt = false;
 	}
 
+	// Check for owner mode in case of a misconfig/dynamic IP addition
+	vrrp_check_for_owner_mode(vrrp);
 	vrrp->effective_priority = vrrp->base_priority;
 	vrrp->total_priority = vrrp->base_priority;
 
@@ -4686,8 +4686,7 @@ vrrp_complete_init(void)
 				if (vrrp->state == VRRP_STATE_FAULT || vrrp->num_script_init)
 					continue;
 
-				vrrp->state = old_vrrp->state;
-				vrrp->wantstate = old_vrrp->state;
+				vrrp->state = vrrp->wantstate = VRRP_STATE_BACK;
 			}
 		}
 
@@ -5049,3 +5048,76 @@ register_vrrp_fifo_addresses(void)
 	register_thread_address("vrrp_notify_fifo_script_exit", vrrp_notify_fifo_script_exit);
 }
 #endif
+
+static bool
+vrrp_check_ipv6_globals_for_ipao(ip_address_t *vip, char * if_name)
+{
+	struct ifaddrs *ifa;
+
+	if (vip->ifa.ifa_family != AF_INET6)
+		return false;
+
+	for (ifa = global_data->local_addresses; ifa != NULL; ifa = ifa->ifa_next) {
+		if (ifa->ifa_addr == NULL ||
+				ifa->ifa_addr->sa_family != AF_INET6 ||
+				strncmp(if_name, ifa->ifa_name, IF_NAMESIZE) != 0)
+			continue;
+		if (inet_inaddrcmp(ifa->ifa_addr->sa_family,
+							&(vip->u.sin6_addr),
+							&(((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr)) == 0) {
+			char addr_str[INET6_ADDRSTRLEN];
+			inet_ntop(ifa->ifa_addr->sa_family, &(((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr), addr_str, sizeof(addr_str));
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void
+vrrp_check_for_owner_mode(vrrp_t *vrrp)
+{
+	bool was_owner = vrrp->addr_owner;
+	ip_address_t *vip;
+	interface_t *ifp = IF_BASE_IFP(vrrp->ifp);
+	struct sockaddr_storage saddr;
+	memset((void *)&saddr, 0, sizeof(struct sockaddr_storage));
+	if (vrrp->family == AF_INET) {
+		inet_ip4tosockaddr(&ifp->sin_addr, &saddr);
+	} else {
+		inet_ip6tosockaddr(&ifp->sin6_addr, &saddr);
+	}
+
+	list_for_each_entry(vip, &vrrp->vip, e_list) {
+		if (vip->ifa.ifa_family == saddr.ss_family) {
+			if (vip->ifa.ifa_family == AF_INET) {
+				if (inet_inaddrcmp(vip->ifa.ifa_family, &vip->u.sin.sin_addr,
+								 &((struct sockaddr_in *)&saddr)->sin_addr) == 0) {
+					vrrp->addr_owner = true;
+					break;
+				}
+			}
+			if (vip->ifa.ifa_family == AF_INET6) {
+				if (vrrp_check_ipv6_globals_for_ipao(vip, IF_NAME(IF_BASE_IFP(ifp))) ||
+					(inet_inaddrcmp(vip->ifa.ifa_family,
+									&vip->u.sin6_addr,
+									&((struct sockaddr_in6 *)&saddr)->sin6_addr) == 0)) {
+					vrrp->addr_owner = true;
+					break;
+				}
+			}
+		}
+	}
+
+	if (was_owner != vrrp->addr_owner) {
+		if (vrrp->addr_owner) {
+			log_message(LOG_DEBUG, "VRRP_Instance(%s) Found a matching VIP for the group, setting this group to IP address owner", vrrp->iname);
+			vrrp->base_priority = vrrp->effective_priority = vrrp->total_priority = VRRP_PRIO_OWNER;
+		} else {
+			log_message(LOG_DEBUG, "VRRP_Instance(%s) Falling out of IP address owner mode, recalculating priorities", vrrp->iname);
+			// Just fallen out of IPAO mode recalculate all priorities
+			vrrp->base_priority = vrrp->effective_priority = vrrp->total_priority = vrrp->configured_priority;
+			initialise_vrrp_tracking_priorities(vrrp);
+		}
+	}
+}
--- a/keepalived/vrrp/vrrp_data.c
+++ b/keepalived/vrrp/vrrp_data.c
@@ -688,7 +688,9 @@ dump_vrrp(FILE *fp, const vrrp_t *vrrp)
 	if (fp) {
 		conf_write(fp, "   Effective priority = %d", vrrp->effective_priority);
 		conf_write(fp, "   Total priority = %d", vrrp->total_priority);
+		conf_write(fp, "   Configured priority = %d", vrrp->configured_priority);
 	}
+	conf_write(fp, "   Address owner = %s", (vrrp->addr_owner? "yes" : "no"));
 	conf_write(fp, "   Advert interval = %u %s",
 		(vrrp->version == VRRP_VERSION_2) ? (vrrp->adver_int / TIMER_HZ) :
 		(vrrp->adver_int / (TIMER_HZ / 1000)),
--- a/keepalived/vrrp/vrrp_parser.c
+++ b/keepalived/vrrp/vrrp_parser.c
@@ -846,6 +846,8 @@ vrrp_prio_handler(const vector_t *strvec
 	}
 	else
 		vrrp->base_priority = (uint8_t)base_priority;
+	vrrp->configured_priority = vrrp->base_priority;
+	vrrp->addr_owner = (vrrp->base_priority == VRRP_PRIO_OWNER);
 }
 static void
 vrrp_adv_handler(const vector_t *strvec)
--- a/keepalived/vrrp/vrrp_track.c
+++ b/keepalived/vrrp/vrrp_track.c
@@ -804,7 +804,7 @@ initialise_process_tracking_priorities(v
 }
 #endif
 
-static void
+void
 initialise_vrrp_tracking_priorities(vrrp_t *vrrp)
 {
 	tracked_sc_t *tsc;
--- a/keepalived/vrrp/vrrp_dbus.c
+++ b/keepalived/vrrp/vrrp_dbus.c
@@ -900,7 +900,7 @@ handle_dbus_msg(__attribute__((unused))
 				else if (ent->action == DBUS_GET_XMIT)
 					ent->args = g_variant_new("(s)", vrrp->ifp->ifname);
 				else if (ent->action == DBUS_GET_IPAO)
-					ent->args = g_variant_new("(b)", false); // restore with dynamic IPAO patch vrrp->addr_owner);
+					ent->args = g_variant_new("(b)", vrrp->addr_owner);
 				else if (ent->action == DBUS_GET_LAST_TRANSITION)
 					ent->args = g_variant_new("(u)", vrrp->last_transition.tv_sec);
 				else if (ent->action == DBUS_GET_SYNC_GROUP)
